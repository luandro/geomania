import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createHash } from 'crypto';
import { countries } from '@/data/countries';

type ConflictGroup = {
  sha256: string;
  countryIds: string[];
};

type Options = {
  outFile: string;
  write: boolean;
  check: boolean;
};

const REPO_ROOT = path.resolve(path.dirname(fileURLToPath(import.meta.url)), '..');

function printHelp() {
  console.log(`
Generate a list of countries that share identical flag SVG content.

This is used to prevent ambiguous "flag" quiz questions where multiple answers
share the same rendered flag.

Usage:
  node --import tsx scripts/generate-flag-conflicts.ts [options]

Options:
  --out <path>   Output TS file (default src/data/flagConflicts.ts)
  --write        Write output file
  --check        Fail if output differs from computed results
  -h, --help     Show help
`);
}

function parseArgs(): Options {
  const argv = process.argv.slice(2);
  const opts: Options = {
    outFile: path.resolve(REPO_ROOT, 'src', 'data', 'flagConflicts.ts'),
    write: false,
    check: false,
  };

  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a === '--out' && argv[i + 1]) {
      opts.outFile = path.resolve(process.cwd(), argv[++i]);
    } else if (a === '--write') {
      opts.write = true;
    } else if (a === '--check') {
      opts.check = true;
    } else if (a === '--help' || a === '-h') {
      printHelp();
      process.exit(0);
    } else {
      throw new Error(`Unknown arg: ${a}`);
    }
  }

  if (opts.write && opts.check) {
    throw new Error('Use either --write or --check (not both).');
  }

  return opts;
}

function sha256(buf: Buffer) {
  return createHash('sha256').update(buf).digest('hex');
}

function formatTs(groups: ConflictGroup[]) {
  const byId = new Map(countries.map((c) => [c.id, c] as const));
  const excludedForFlagMode = new Set<string>();

  for (const group of groups) {
    const present = group.countryIds.map((id) => byId.get(id)).filter(Boolean);
    if (present.length < 2) continue;

    const hasAnchorCountry = present.some(
      (c) => c.difficulty !== 'super_hard' && c.difficulty !== 'god_mode'
    );

    if (!hasAnchorCountry) {
      for (const c of present) excludedForFlagMode.add(c.id);
      continue;
    }

    const keep = present.reduce((best, current) => {
      if (current.population > best.population) return current;
      if (current.population < best.population) return best;
      return current.id.localeCompare(best.id) < 0 ? current : best;
    }, present[0]);

    for (const c of present) {
      if (c.id !== keep.id) excludedForFlagMode.add(c.id);
    }
  }

  const excludedList = Array.from(excludedForFlagMode).sort((a, b) => a.localeCompare(b));

  return `// This file is auto-generated by scripts/generate-flag-conflicts.ts
// Do not edit manually.
//
// Why: Some territories share the same flag SVG in our current source set, which
// makes the flag quiz ambiguous (multiple correct answers for one image).

export type FlagConflictGroup = {
  sha256: string;
  countryIds: string[];
};

export const FLAG_CONFLICT_GROUPS: FlagConflictGroup[] = ${JSON.stringify(groups, null, 2)};

export const FLAG_CONFLICT_COUNTRY_IDS = new Set<string>(
  FLAG_CONFLICT_GROUPS.flatMap((g) => g.countryIds)
);

// Flag-mode policy (simplest): exclude all non-anchor duplicates globally.
// - If a group includes any non-('super_hard'|'god_mode') country, keep the highest-population entry.
// - If a group is only 'super_hard'/'god_mode' entries, exclude the entire group (usually placeholder flags).
export const FLAG_MODE_EXCLUDED_COUNTRY_IDS = new Set<string>(${JSON.stringify(excludedList, null, 2)});
`;
}

function computeGroups(): ConflictGroup[] {
  const byHash = new Map<string, string[]>();
  const missing: { id: string; flag_url: string }[] = [];

  for (const c of countries) {
    const flagUrl = c.flag_url;
    if (!flagUrl) continue;

    const rel = flagUrl.startsWith('/') ? flagUrl.slice(1) : flagUrl;
    const file = path.resolve(REPO_ROOT, 'public', rel);
    if (!fs.existsSync(file)) {
      missing.push({ id: c.id, flag_url: flagUrl });
      continue;
    }

    const hash = sha256(fs.readFileSync(file));
    const list = byHash.get(hash) || [];
    list.push(c.id);
    byHash.set(hash, list);
  }

  if (missing.length) {
    console.warn(`⚠ missing flag files for ${missing.length} countries (sample):`);
    for (const m of missing.slice(0, 10)) console.warn(`  - ${m.id}: ${m.flag_url}`);
    if (missing.length > 10) console.warn(`  ...and ${missing.length - 10} more`);
  }

  const groups: ConflictGroup[] = Array.from(byHash.entries())
    .filter(([, ids]) => ids.length > 1)
    .map(([hash, ids]) => ({
      sha256: hash,
      countryIds: [...ids].sort((a, b) => a.localeCompare(b)),
    }))
    .sort((a, b) => {
      if (b.countryIds.length !== a.countryIds.length) return b.countryIds.length - a.countryIds.length;
      return a.sha256.localeCompare(b.sha256);
    });

  return groups;
}

function main() {
  const opts = parseArgs();
  const groups = computeGroups();
  const out = formatTs(groups);

  const totalConflicts = groups.reduce((acc, g) => acc + g.countryIds.length, 0);
  console.log(`Found ${groups.length} duplicate-flag groups affecting ${totalConflicts} countries.`);
  for (const g of groups.slice(0, 10)) {
    console.log(`- ${g.countryIds.length} countries share sha256=${g.sha256.slice(0, 12)}…: ${g.countryIds.join(', ')}`);
  }
  if (groups.length > 10) console.log(`...and ${groups.length - 10} more groups`);

  if (opts.check) {
    const existing = fs.existsSync(opts.outFile) ? fs.readFileSync(opts.outFile, 'utf-8') : '';
    if (existing !== out) {
      console.error(`✗ ${opts.outFile} is out of date. Run: npm run generate:flag-conflicts`);
      process.exit(1);
    }
    console.log(`✓ ${opts.outFile} is up to date`);
    return;
  }

  if (opts.write) {
    fs.mkdirSync(path.dirname(opts.outFile), { recursive: true });
    fs.writeFileSync(opts.outFile, out);
    console.log(`✓ Wrote ${opts.outFile}`);
    return;
  }

  console.log('Dry run: pass --write to update the output file.');
}

main();
